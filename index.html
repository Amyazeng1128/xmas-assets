<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>3D 模型实体测试</title>
    <style>
        body { margin: 0; overflow: hidden; background: #888; } /* 灰色背景 */
        #info {
            position: absolute; top: 10px; left: 10px; 
            color: white; background: rgba(0,0,0,0.5); padding: 10px; 
            font-family: sans-serif; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">正在加载实体模型 (无特效版)...</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // 1. 创建简单场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x808080); // 纯灰色背景，最容易看清模型

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1, 3); // 相机位置

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 2. 加灯光 (没灯光模型就是黑的)
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0); // 强白光
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // 3. 加载模型
        const loader = new THREE.GLTFLoader();
        console.log("开始加载 ./horse.glb ...");
        
        loader.load('./horse.glb', (gltf) => {
            console.log("模型加载成功！", gltf);
            document.getElementById('info').innerText = "加载成功！你看到马了吗？(可用鼠标旋转)";
            
            const model = gltf.scene;

            // --- 强制修正模型大小和位置 ---
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            // 把它缩放到高度为 2
            const scale = 2.0 / (size.y || 1); 
            model.scale.set(scale, scale, scale);
            
            // 把它居中
            model.position.x = -center.x * scale;
            model.position.y = -center.y * scale;
            model.position.z = -center.z * scale;

            scene.add(model);

            // 播放动画
            const mixer = new THREE.AnimationMixer(model);
            if(gltf.animations.length > 0) {
                mixer.clipAction(gltf.animations[0]).play();
            }

            // 渲染循环
            const clock = new THREE.Clock();
            function animate() {
                requestAnimationFrame(animate);
                mixer.update(clock.getDelta());
                renderer.render(scene, camera);
            }
            animate();

        }, 
        // 加载进度
        (xhr) => {
            const percent = (xhr.loaded / xhr.total * 100).toFixed(0) + '%';
            document.getElementById('info').innerText = "正在下载模型: " + percent;
            console.log("下载进度:", percent);
        },
        // 报错处理
        (error) => {
            console.error("加载失败:", error);
            document.getElementById('info').innerText = "❌ 失败: " + error.message;
            document.getElementById('info').style.backgroundColor = "red";
        });

        // 窗口缩放适配
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
