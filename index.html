<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>马年祈福 | 2026</title>
    <style>
        /* 1. 强制设置深色背景，防止白屏 */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #2a0000; /* 纯色保底 */
            background-image: radial-gradient(circle, #4a0404 0%, #000000 100%); 
            font-family: 'STKaiti', 'Microsoft YaHei', serif; 
            color: #ffcf67; 
        }
        
        #canvas-container { position: fixed; width: 100%; height: 100%; z-index: 1; }
        
        /* 加载提示 */
        #loading { 
            position: fixed; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 1.2rem; color: white; z-index: 20; 
            background: rgba(0,0,0,0.8); padding: 20px 40px; 
            border-radius: 10px; border: 1px solid #ffcf67;
            text-align: center;
        }

        /* UI 层 */
        #ui-layer { 
            position: absolute; z-index: 10; width: 100%; height: 100%; 
            pointer-events: none; padding: 40px; box-sizing: border-box; 
            display: flex; flex-direction: column; justify-content: space-between; 
        }
        h1 { margin: 0; text-shadow: 0 0 10px rgba(255, 207, 103, 0.8); text-align: center;}
        
        .controls { 
            pointer-events: auto; position: absolute; right: 20px; top: 50%; 
            transform: translateY(-50%); background: rgba(0,0,0,0.6); 
            padding: 20px; border: 1px solid #ffcf67; border-radius: 8px;
        }
    </style>
</head>
<body>

    <div id="loading">
        正在解析模型...<br>
        <span style="font-size: 0.8em; color: #aaa;">(如果长时间不动，请刷新)</span>
    </div>
    
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <h1>乙巳马年 · 祈福</h1>
        <div class="controls">
            <label>动画速度</label><br>
            <input type="range" id="speed" min="0" max="3" step="0.1" value="1" style="accent-color: #ffcf67;">
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        const MODEL_PATH = './horse.glb';
        
        let scene, camera, renderer, mixer, controls;
        let horseWrapper; // 这是一个盒子，用来装马

        function init() {
            // 1. 场景
            scene = new THREE.Scene();
            // 即使CSS背景失败，这里也设置一个深色雾气作为保底
            scene.background = new THREE.Color(0x110000); 
            scene.fog = new THREE.Fog(0x110000, 10, 50);

            // 2. 相机 (视距拉大到 100000，防止大模型被切掉)
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100000);
            camera.position.set(0, 5, 10); // 初始位置

            // 3. 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. 灯光 (全方位打光)
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffd700, 2); // 金光
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);
            const backLight = new THREE.DirectionalLight(0xffffff, 1); // 背光
            backLight.position.set(-5, 5, -10);
            scene.add(backLight);

            // 5. 辅助工具 (网格和坐标轴，帮你确认场景是否加载)
            // 地面网格：大小 200，分 20 格
            const gridHelper = new THREE.GridHelper(200, 20, 0x444444, 0x222222);
            scene.add(gridHelper);
            // 坐标轴：红=X, 绿=Y, 蓝=Z (长度5)
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);

            // 6. 控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // 7. 加载模型
            loadModelWrapper();

            // 8. 循环
            animate();
            
            // UI
            document.getElementById('speed').addEventListener('input', (e) => {
                if(mixer) mixer.timeScale = Number(e.target.value);
            });
            window.addEventListener('resize', onResize);
        }

        function loadModelWrapper() {
            const loader = new THREE.GLTFLoader();
            loader.load(MODEL_PATH, (gltf) => {
                document.getElementById('loading').style.display = 'none';
                
                const rawModel = gltf.scene;
                
                // === 核心修复技术：容器包裹法 ===
                
                // 1. 创建一个盒子(Group)放到场景中心
                horseWrapper = new THREE.Group();
                scene.add(horseWrapper);
                
                // 2. 把马放进盒子里
                horseWrapper.add(rawModel);

                // 3. 计算马的尺寸和偏差
                const box = new THREE.Box3().setFromObject(rawModel);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                console.log("原始模型尺寸:", size);
                console.log("原始模型中心:", center);

                // 4. 【关键修正】把马挪到盒子的中心
                // 这样无论马原来的坐标偏移了多少，它都会回到盒子的(0,0,0)
                rawModel.position.x = -center.x;
                rawModel.position.y = -center.y;
                rawModel.position.z = -center.z;

                // 5. 【关键缩放】缩放盒子，而不是缩放马
                // 目标：让马看起来大约 6 米高
                const maxDim = Math.max(size.x, size.y, size.z);
                const targetSize = 6.0; 
                const scaleFactor = targetSize / (maxDim || 1); // 防止除以0
                
                horseWrapper.scale.set(scaleFactor, scaleFactor, scaleFactor);
                
                // 6. 把它稍微抬高一点，站在网格面上
                horseWrapper.position.y = targetSize / 2;

                // 7. 材质美化：全部刷成金色
                const goldMat = new THREE.MeshStandardMaterial({
                    color: 0xffd700,
                    metalness: 0.8,
                    roughness: 0.2,
                    emissive: 0x220000
                });
                
                rawModel.traverse(child => {
                    if (child.isMesh) {
                        child.material = goldMat;
                        child.castShadow = true;
                    }
                });

                // 8. 播放动画
                mixer = new THREE.AnimationMixer(rawModel);
                if (gltf.animations.length > 0) {
                    mixer.clipAction(gltf.animations[0]).play();
                }

            }, 
            (xhr) => {
                // 加载进度
                if(xhr.total > 0) {
                    const percent = Math.round((xhr.loaded / xhr.total * 100));
                    document.getElementById('loading').innerHTML = `正在搬运天马... ${percent}%`;
                }
            },
            (err) => {
                console.error(err);
                document.getElementById('loading').innerHTML = `❌ 加载失败<br>请检查 horse.glb 是否上传`;
                document.getElementById('loading').style.borderColor = "red";
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            if (mixer) mixer.update(0.016);
            controls.update();
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
