<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>马年祈福 - 3D 粒子交互 (修复版)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        #canvas-container { width: 100vw; height: 100vh; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #d4af37; font-family: sans-serif; font-size: 24px; pointer-events: none;
            text-shadow: 0 0 10px #d4af37;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="loading">正在凝聚祈福之力 (加载模型)...</div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const PARTICLE_COUNT = 20000;
        const WING_PARTICLE_COUNT = 3000;
        const MODEL_URL = 'https://threejs.org/examples/models/gltf/Horse.glb';
        
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.005);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 100, 350);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.8;
        controls.target.set(0, 60, 0);

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.5;
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        let mixer;
        let horseMesh;
        let particleSystem;
        let wingsSystem;
        const clock = new THREE.Clock();
        const particleData = []; 

        const loader = new GLTFLoader();
        loader.load(MODEL_URL, (gltf) => {
            document.getElementById('loading').style.display = 'none';
            
            const model = gltf.scene.children[0];
            model.scale.set(0.5, 0.5, 0.5);
            
            horseMesh = model;
            horseMesh.visible = false;
            scene.add(horseMesh);

            mixer = new THREE.AnimationMixer(horseMesh);
            const clip = gltf.animations[0];
            const action = mixer.clipAction(clip);
            action.play();
            
            createHorseParticles(horseMesh.geometry);
            createProceduralWings();
            animate();

        }, undefined, (error) => {
            console.error(error);
            document.getElementById('loading').innerText = "加载失败，请检查网络或跨域设置";
        });

        // --- 修复后的核心函数：创建粒子 ---
        function createHorseParticles(geometry) {
            const posAttribute = geometry.attributes.position;
            const indexAttribute = geometry.index; // 获取索引属性
            
            // 正确计算面数
            const totalFaces = indexAttribute ? indexAttribute.count / 3 : posAttribute.count / 3;
            const faceAreas = [];
            let totalArea = 0;
            const tempA = new THREE.Vector3();
            const tempB = new THREE.Vector3();
            const tempC = new THREE.Vector3();

            for (let i = 0; i < totalFaces; i++) {
                // 核心修复：根据是否有索引来获取顶点索引
                let aIndex, bIndex, cIndex;
                if (indexAttribute) {
                    aIndex = indexAttribute.getX(i * 3 + 0);
                    bIndex = indexAttribute.getX(i * 3 + 1);
                    cIndex = indexAttribute.getX(i * 3 + 2);
                } else {
                    aIndex = i * 3 + 0;
                    bIndex = i * 3 + 1;
                    cIndex = i * 3 + 2;
                }

                tempA.fromBufferAttribute(posAttribute, aIndex);
                tempB.fromBufferAttribute(posAttribute, bIndex);
                tempC.fromBufferAttribute(posAttribute, cIndex);
                
                tempB.sub(tempA);
                tempC.sub(tempA);
                tempB.cross(tempC);
                const area = 0.5 * tempB.length();
                
                faceAreas.push(area);
                totalArea += area;
            }

            const particleGeo = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(PARTICLE_COUNT * 3);
            const particleColors = new Float32Array(PARTICLE_COUNT * 3);

            const color1 = new THREE.Color(0xffcc00); // 金色
            const color2 = new THREE.Color(0xff3300); // 橙红

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let r = Math.random() * totalArea;
                let faceIndex = 0;
                for (let j = 0; j < totalFaces; j++) {
                    r -= faceAreas[j];
                    if (r <= 0) {
                        faceIndex = j;
                        break;
                    }
                }

                let u = Math.random();
                let v = Math.random();
                if (u + v > 1) { u = 1 - u; v = 1 - v; }
                const w = 1 - u - v;

                particleData.push({ faceIndex, u, v, w });

                const mixColor = color1.clone().lerp(color2, Math.random() * 0.7);
                particleColors[i * 3] = mixColor.r;
                particleColors[i * 3 + 1] = mixColor.g;
                particleColors[i * 3 + 2] = mixColor.b;
            }

            particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particleGeo.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 1.0,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.9
            });

            particleSystem = new THREE.Points(particleGeo, particleMaterial);
            scene.add(particleSystem);
            // 立即更新一次位置，避免初始帧在原点
            updateHorseParticles();
        }

        function createProceduralWings() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const wingColor = new THREE.Color(0x00ffff);
            const whiteColor = new THREE.Color(0xffffff);

            for (let side = -1; side <= 1; side += 2) {
                for (let i = 0; i < WING_PARTICLE_COUNT / 2; i++) {
                    const t = Math.random();
                    const s = Math.random();
                    const x = 60 * t + 5; 
                    const y = 90 * Math.pow(t, 0.6) * (s * 0.3 + 0.7) - 10; 
                    const z = 25 * Math.sin(t * Math.PI) + (Math.random() - 0.5) * 8;

                    positions.push(side * x, y, z);
                    const c = wingColor.clone().lerp(whiteColor, Math.pow(t, 3));
                    colors.push(c.r, c.g, c.b);
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('initialPos', new THREE.Float32BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                size: 0.6,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.5
            });

            wingsSystem = new THREE.Points(geometry, material);
            wingsSystem.position.set(0, 90, 20);
            scene.add(wingsSystem);
        }

        // --- 修复后的核心函数：更新粒子位置 ---
        function updateHorseParticles() {
            if (!particleSystem || !horseMesh) return;

            const geometry = horseMesh.geometry;
            const posAttr = geometry.attributes.position;
            const indexAttribute = geometry.index; // 获取索引
            const morphAttr = geometry.morphAttributes.position;
            const influences = horseMesh.morphTargetInfluences;
            
            const positions = particleSystem.geometry.attributes.position.array;
            
            const vA = new THREE.Vector3(); const vB = new THREE.Vector3(); const vC = new THREE.Vector3();
            const mA = new THREE.Vector3(); const mB = new THREE.Vector3(); const mC = new THREE.Vector3();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const data = particleData[i];
                const fi = data.faceIndex;

                // 核心修复：同样需要根据索引获取顶点
                let aIndex, bIndex, cIndex;
                if (indexAttribute) {
                    aIndex = indexAttribute.getX(fi * 3 + 0);
                    bIndex = indexAttribute.getX(fi * 3 + 1);
                    cIndex = indexAttribute.getX(fi * 3 + 2);
                } else {
                    aIndex = fi * 3 + 0;
                    bIndex = fi * 3 + 1;
                    cIndex = fi * 3 + 2;
                }

                vA.fromBufferAttribute(posAttr, aIndex);
                vB.fromBufferAttribute(posAttr, bIndex);
                vC.fromBufferAttribute(posAttr, cIndex);

                if (morphAttr && influences) {
                    for (let t = 0; t < morphAttr.length; t++) {
                        const influence = influences[t];
                        if (influence < 0.001) continue;
                        // Morph target 数据也要用正确的索引获取
                        mA.fromBufferAttribute(morphAttr[t], aIndex);
                        mB.fromBufferAttribute(morphAttr[t], bIndex);
                        mC.fromBufferAttribute(morphAttr[t], cIndex);
                        vA.addScaledVector(mA, influence);
                        vB.addScaledVector(mB, influence);
                        vC.addScaledVector(mC, influence);
                    }
                }

                positions[i * 3] = data.u * vA.x + data.v * vB.x + data.w * vC.x;
                positions[i * 3 + 1] = data.u * vA.y + data.v * vB.y + data.w * vC.y;
                positions[i * 3 + 2] = data.u * vA.z + data.v * vB.z + data.w * vC.z;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.position.copy(horseMesh.position);
            particleSystem.rotation.copy(horseMesh.rotation);
            particleSystem.scale.copy(horseMesh.scale);
        }

        function updateWings(time) {
            if (!wingsSystem) return;
            const positions = wingsSystem.geometry.attributes.position.array;
            const initialPos = wingsSystem.geometry.attributes.initialPos.array;
            const count = wingsSystem.geometry.attributes.position.count;
            const angle = Math.sin(time * 4) * 0.4;

            for (let i = 0; i < count; i++) {
                const ix = initialPos[i * 3];
                const iy = initialPos[i * 3 + 1];
                const iz = initialPos[i * 3 + 2];
                const side = Math.sign(ix);
                const currentAngle = angle * side; 
                
                let nx = ix * Math.cos(currentAngle) - iy * Math.sin(currentAngle);
                let ny = ix * Math.sin(currentAngle) + iy * Math.cos(currentAngle);
                const wave = Math.sin(time * 8 + Math.abs(ix) * 0.05 - iy * 0.02) * 3;

                positions[i * 3] = nx;
                positions[i * 3 + 1] = ny + wave;
                positions[i * 3 + 2] = iz;
            }
            wingsSystem.geometry.attributes.position.needsUpdate = true;
            wingsSystem.position.y = 90 + Math.sin(time * 8) * 4; 
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            if (mixer) mixer.update(delta);
            updateHorseParticles();
            updateWings(time);
            controls.update();
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
