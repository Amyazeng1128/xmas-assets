<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>马年祈福 - 3D 粒子交互</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        #canvas-container { width: 100vw; height: 100vh; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #d4af37; font-family: sans-serif; font-size: 24px; pointer-events: none;
            text-shadow: 0 0 10px #d4af37;
        }
    </style>
</head>
<body>
    <div id="loading">正在凝聚祈福之力 (加载模型)...</div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 配置参数 ---
        const PARTICLE_COUNT = 20000;
        const WING_PARTICLE_COUNT = 3000;
        const MODEL_URL = 'https://threejs.org/examples/models/gltf/Horse.glb';
        
        // --- 场景初始化 ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.005);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 100, 300);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.0;

        // --- 后处理 (Bloom Effect) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2; // 辉光强度
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 变量定义 ---
        let mixer;
        let horseMesh; // 原始网格（隐藏）
        let particleSystem; // 马的粒子系统
        let wingsSystem; // 翅膀系统
        const clock = new THREE.Clock();
        
        // 存储粒子的重心坐标数据
        // 结构: [faceIndex, u, v, w]
        const particleData = []; 

        // --- 加载模型 ---
        const loader = new GLTFLoader();
        loader.load(MODEL_URL, (gltf) => {
            document.getElementById('loading').style.display = 'none';
            
            const model = gltf.scene.children[0];
            model.scale.set(0.5, 0.5, 0.5); // 调整大小
            
            // 获取原始 Mesh
            horseMesh = model;
            horseMesh.visible = false; // 隐藏原始模型，只显示粒子
            scene.add(horseMesh);

            // 初始化动画混合器
            mixer = new THREE.AnimationMixer(horseMesh);
            const clip = gltf.animations[0];
            const action = mixer.clipAction(clip);
            action.play();
            
            // 1. 生成马身粒子
            createHorseParticles(horseMesh.geometry);
            
            // 2. 生成程序化翅膀
            createProceduralWings();

            // 开始循环
            animate();

        }, undefined, (error) => {
            console.error(error);
            document.getElementById('loading').innerText = "加载失败，请检查网络";
        });

        // --- 核心逻辑：创建跟随动画的粒子 (利用重心坐标) ---
        function createHorseParticles(geometry) {
            const posAttribute = geometry.attributes.position;
            const indexAttribute = geometry.index; // 可能是 null，如果是 BufferGeometry 非索引的
            
            // 预计算三角形面积用于加权随机采样
            // 注意：标准的 Horse.glb 是非索引的或简单的，这里为了通用性处理
            const totalFaces = posAttribute.count / 3;
            const faceAreas = [];
            let totalArea = 0;
            const tempA = new THREE.Vector3();
            const tempB = new THREE.Vector3();
            const tempC = new THREE.Vector3();

            for (let i = 0; i < totalFaces; i++) {
                tempA.fromBufferAttribute(posAttribute, i * 3 + 0);
                tempB.fromBufferAttribute(posAttribute, i * 3 + 1);
                tempC.fromBufferAttribute(posAttribute, i * 3 + 2);
                
                // 计算三角形面积：0.5 * |(B-A) x (C-A)|
                tempB.sub(tempA);
                tempC.sub(tempA);
                tempB.cross(tempC);
                const area = 0.5 * tempB.length();
                
                faceAreas.push(area);
                totalArea += area;
            }

            // 初始化粒子几何体
            const particleGeo = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(PARTICLE_COUNT * 3);
            const particleColors = new Float32Array(PARTICLE_COUNT * 3);

            const color1 = new THREE.Color(0xffd700); // 金色
            const color2 = new THREE.Color(0xff4500); // 红橙色

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // 基于面积权重随机选择一个面
                let r = Math.random() * totalArea;
                let faceIndex = 0;
                for (let j = 0; j < totalFaces; j++) {
                    r -= faceAreas[j];
                    if (r <= 0) {
                        faceIndex = j;
                        break;
                    }
                }

                // 生成随机重心坐标 (Barycentric Coordinates)
                // P = uA + vB + wC, where u+v+w = 1
                let u = Math.random();
                let v = Math.random();
                if (u + v > 1) {
                    u = 1 - u;
                    v = 1 - v;
                }
                const w = 1 - u - v;

                // 存储引用数据，以便在动画帧中更新
                particleData.push({ faceIndex, u, v, w });

                // 初始化颜色
                const mixColor = color1.clone().lerp(color2, Math.random());
                particleColors[i * 3] = mixColor.r;
                particleColors[i * 3 + 1] = mixColor.g;
                particleColors[i * 3 + 2] = mixColor.b;
            }

            particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particleGeo.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 0.8,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particleSystem = new THREE.Points(particleGeo, particleMaterial);
            scene.add(particleSystem);
        }

        // --- 核心逻辑：创建程序化翅膀 ---
        function createProceduralWings() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const speeds = []; // 用于动画偏移

            const wingColor = new THREE.Color(0x00ffff); // 青色光翼
            const whiteColor = new THREE.Color(0xffffff);

            // 生成一对翅膀
            for (let side = -1; side <= 1; side += 2) {
                for (let i = 0; i < WING_PARTICLE_COUNT / 2; i++) {
                    // 数学函数生成羽翼形状
                    const t = Math.random();
                    const s = Math.random();
                    
                    // 简化的翅膀参数方程
                    // x: 翼展长度, y: 高度, z: 弯曲度
                    const x = 50 * t + 10; 
                    const y = 80 * Math.pow(t, 0.5) * (s * 0.4 + 0.6) - 20; 
                    const z = 20 * Math.sin(t * Math.PI) + (Math.random() - 0.5) * 5;

                    positions.push(side * x, y, z); // Side 决定左右

                    // 颜色渐变
                    const c = wingColor.clone().lerp(whiteColor, Math.pow(t, 2));
                    colors.push(c.r, c.g, c.b);

                    speeds.push(Math.random());
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            // 存储初始位置用于动画计算
            geometry.setAttribute('initialPos', new THREE.Float32BufferAttribute(positions, 3));
            geometry.userData = { speeds: speeds };

            const material = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.6
            });

            wingsSystem = new THREE.Points(geometry, material);
            
            // 将翅膀挂载到一个容器上，方便整体跟随
            // 这里我们手动调整位置到马背上方
            wingsSystem.position.y = 80; 
            wingsSystem.position.z = 20;
            scene.add(wingsSystem);
        }

        // --- 动画循环更新 ---
        function updateHorseParticles() {
            if (!particleSystem || !horseMesh) return;

            const geometry = horseMesh.geometry;
            const posAttr = geometry.attributes.position;
            const morphAttr = geometry.morphAttributes.position; // 获取变形目标数据
            
            // 必须获取当前的 Morph 权重
            const influences = horseMesh.morphTargetInfluences;
            
            // 我们需要手动计算当前帧所有顶点的真实位置
            // 这是一个较重的 CPU 操作，但在 20k 粒子下现代浏览器通常能处理
            // 优化：仅计算被采样到的面涉及的顶点？为了代码简洁，我们在循环内即时计算
            
            const positions = particleSystem.geometry.attributes.position.array;
            
            const vA = new THREE.Vector3();
            const vB = new THREE.Vector3();
            const vC = new THREE.Vector3();
            
            // 临时向量用于计算 Morph 偏移
            const mA = new THREE.Vector3();
            const mB = new THREE.Vector3();
            const mC = new THREE.Vector3();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const data = particleData[i];
                const fi = data.faceIndex;

                // 1. 获取基础位置 (Rest Pose)
                vA.fromBufferAttribute(posAttr, fi * 3 + 0);
                vB.fromBufferAttribute(posAttr, fi * 3 + 1);
                vC.fromBufferAttribute(posAttr, fi * 3 + 2);

                // 2. 应用 Morph Targets (动画变形)
                // 标准 Horse.glb 有两个 MorphTargets
                if (morphAttr && influences) {
                    for (let t = 0; t < morphAttr.length; t++) {
                        const influence = influences[t];
                        if (influence === 0) continue;

                        const morphTarget = morphAttr[t];
                        
                        mA.fromBufferAttribute(morphTarget, fi * 3 + 0);
                        mB.fromBufferAttribute(morphTarget, fi * 3 + 1);
                        mC.fromBufferAttribute(morphTarget, fi * 3 + 2);

                        vA.addScaledVector(mA, influence);
                        vB.addScaledVector(mB, influence);
                        vC.addScaledVector(mC, influence);
                    }
                }

                // 3. 应用重心坐标插值计算最终粒子位置
                // P = u*A + v*B + w*C
                const x = data.u * vA.x + data.v * vB.x + data.w * vC.x;
                const y = data.u * vA.y + data.v * vB.y + data.w * vC.y;
                const z = data.u * vA.z + data.v * vB.z + data.w * vC.z;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
            
            // 同步马的整体 Transform（虽然此示例中马在原地跑，但如果有位移需要加上）
            particleSystem.position.copy(horseMesh.position);
            particleSystem.rotation.copy(horseMesh.rotation);
            particleSystem.scale.copy(horseMesh.scale);
        }

        function updateWings(time) {
            if (!wingsSystem) return;

            const positions = wingsSystem.geometry.attributes.position.array;
            const initialPos = wingsSystem.geometry.attributes.initialPos.array;
            const count = wingsSystem.geometry.attributes.position.count;

            // 扇动角度
            const flapSpeed = 5;
            const flapAmp = 0.5; // 扇动幅度
            const angle = Math.sin(time * flapSpeed) * flapAmp;
            
            const cosA = Math.cos(angle);
            const sinA = Math.sin(angle);

            for (let i = 0; i < count; i++) {
                const ix = initialPos[i * 3];
                const iy = initialPos[i * 3 + 1];
                const iz = initialPos[i * 3 + 2];

                // 简单的绕 Z 轴旋转模拟扇动
                // 注意：左右翅膀需要反向旋转，通过判断 ix 的正负
                const side = Math.sign(ix);
                const currentAngle = angle * side; 
                
                // 旋转逻辑 (绕原点，即马背中心)
                // x' = x cos - y sin
                // y' = x sin + y cos
                let nx = ix * Math.cos(currentAngle) - iy * Math.sin(currentAngle);
                let ny = ix * Math.sin(currentAngle) + iy * Math.cos(currentAngle);
                let nz = iz;

                // 增加一点波浪起伏，让翅膀更灵动
                ny += Math.sin(time * 10 + ix * 0.1) * 2;

                positions[i * 3] = nx;
                positions[i * 3 + 1] = ny;
                positions[i * 3 + 2] = nz;
            }
            wingsSystem.geometry.attributes.position.needsUpdate = true;
            
            // 翅膀整体跟随马身位置（轻微上下浮动）
            wingsSystem.position.y = 120 + Math.sin(time * 10) * 5; 
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            if (mixer) mixer.update(delta);

            updateHorseParticles();
            updateWings(time);
            controls.update();

            composer.render();
        }

        // 窗口调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
